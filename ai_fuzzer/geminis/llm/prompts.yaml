_defaults: &defaults
  model: gemini-2.5-flash
  top_p: 1.0
  # max_tokens: 2048

base:
  <<: *defaults
  temperature: 0.3
  description: >
    Original prompt that does work and outputs python atheris harnesses.
  template: |
    You are an expert in software security and automated testing, specializing in fuzzing with Python's Atheris framework. Your task is to create a complete and runnable Python fuzzing harness for a target function that will be provided to you.

    Follow these steps precisely:

    **1. Analyze the Target Function:**
    - Examine the Python function provided below under "TARGET FUNCTION".
    - Identify the function's name and all of its input arguments.
    - Determine the expected data type for each argument (e.g., `string`, `integer`, `bytes`, `list of integers`).

    **2. Plan the Fuzzing Strategy:**
    - Based on the argument types, determine the appropriate `FuzzedDataProvider` methods to use for generating each input (e.g., `fdp.ConsumeUnicode()`, `fdp.ConsumeInt()`, `fdp.ConsumeBytes()`, `fdp.ConsumeIntList()`).
    - The goal is to map the raw fuzzer data to the function's expected input signature.

    **3. Generate the Fuzzing Harness Code:**
    - Write a single, self-contained Python script.
    - **Imports:** The script must import `atheris`, `sys`, and any other libraries required by the target function itself. You must ensure the ability to install these locally in the generated code, any package that is not python native needs to be installed in the generated code.  You can do this by creating the python code that actually uses the command pip install and then the package names setuptools, and wheel prior to atheris.
    - **Dependency Management:** At the very top of the script, do the actual `pip install` commands needed to run the code (e.g., `pip install atheris`, `pip install library-used-by-target`). Ensure you **INSTALL THE REQUIRED LIBRARIES** before **IMPORTING ANY NON NATIVE PYTHON PACKAGES**
    - **Target Function:** Include the complete target function code within the script so it is self-contained.
    - **Test Harness Function:** Define the core `TestOneInput(data)` function.
    - **Data Provider:** Inside `TestOneInput`, initialize the `atheris.FuzzedDataProvider(data)`.
    - **Input Generation:** Use the data provider to generate values for each of the target function's arguments according to your plan in step 2.
    - **Function Call:** Call the target function with the generated inputs inside a `try...except Exception` block. This is crucial for catching crashes and other errors.
    - **Logging and Data Persistence:**
    - **Create a crash-only logger by opening one log file at startup—os.open(path, O_WRONLY|O_CREAT|O_APPEND, 0o644)—and reusing that file descriptor globally. In TestOneInput, wrap the target code in a try/except, and on any exception base64-encode the input, build a single-line record (<epoch-ns>|<pid>|<b64>|<exception> \n), append it to a bytearray buffer, then exception so Atheris still registers the crash. When the buffer exceeds 64 KiB, flush with one os.write(fd, buf); also flush once more via an atexit handler. Give each worker its own file (exceptions.<pid>.log) to avoid contention, keep logs append-only and line-oriented, and use only os and base64—no dynamic configs, locks, or heavy libraries—to ensure zero impact on fuzzing throughput. Also ensure that a single crash does not stop the fuzzing.
    - **Atheris Setup:** After the function definitions, properly initialize Atheris with `atheris.Setup(sys.argv, TestOneInput)` and start the fuzzer with `atheris.Fuzz()`. Also ensure that you enable instrumentation in the atheris.Setup() with enable_python_coverage=True.

    **4. Final Output:**
    - The final output must be ONLY the Python code in a single code block.
    - Do not provide explanations or text outside of the code block.
    - The code must be fully commented, explaining the logic of the harness, the input generation, and the error handling.

    Before getting started, you must understand how the atheris tool works. Please understand read and understand the README before writing the harness.

    {{DOCS}}

    ---
    **TARGET FUNCTION:**

    {{CODE}}
    ---

testing:
  <<: *defaults
  temperature: 0.3
  description: >
    Improved prompt to generate fast, deterministic Atheris harnesses that actually reach the target, assert properties, and surface crashes. Keeps your requirement to install packages inside the harness.
  template: |
    You are an expert in software security and Python fuzzing with Atheris. Generate a minimal, deterministic, runnable fuzzing harness for the function under “TARGET FUNCTION”. Your output **must be only one Python code block** (no prose). The script must:
    - Install required non-stdlib packages **at the very top**.
    - Import the real target under Atheris instrumentation (no mocks).
    - Drive realistic, structure-aware inputs via `FuzzedDataProvider`.
    - Include **crash-inducing property assertions** derived from the targets semantics.
    - Re-raise exceptions so libFuzzer/Atheris can write crash artifacts.
    - Start Atheris with `enable_python_coverage=True`.
    - Be fast: no sleeps, prints, threads, or heavy logging in the hot path.

    ---
    ## 1) Analyze the Target (do this before writing code)
    - Identify the function name and **all** parameters from “TARGET FUNCTION”.
    - Infer types and constraints (lengths, ranges, enums, regexes, encodings).
    - Note any **preconditions/invariants** from docstrings, comments, or code (e.g., idempotence, monotonicity, ordering, round-trip, charset/UTF-8 invariants).
    - If arguments are interdependent (e.g., `len(data) == n`, or `index < len(seq)`), record those constraints.

    ---
    ## 2) Input Strategy (must reflect real structure)
    Map each parameter to an appropriate generator from `atheris.FuzzedDataProvider`:
    - Text: `ConsumeUnicodeNoSurrogates(n)` or `ConsumeString(n, allow_surrogates=False)`.
    - Bytes: `ConsumeBytes(n)`.
    - Ints: `ConsumeIntInRange(lo, hi)`; respect domain constraints from analysis.
    - Floats: `ConsumeFloat()`, clamp if needed.
    - Bools: `ConsumeBool()`.
    - Collections: consume a bounded length and fill elements with appropriate types.
    - When the target expects **structured** inputs (JSON/XML/paths/ids):
      - Use small combinators: choose(kind) → branch into realistic constructors.
      - Build **valid-by-default** values first; allow some chance for malformed cases.

    ---
    ## 3) Properties (this is how we turn logic bugs into crashes)
    Implement at least **three** assertions that should always hold if the target is correct. Choose from:
    - **Idempotence on “safe” inputs** (e.g., escaping twice ≡ once).
    - **Round-trip** (`decode(encode(x)) == x` under constraints).
    - **Monotonic / ordering** guarantees.
    - **Pre/post conditions** (e.g., “no unescaped `<>&\"'` remain”, “length doesnt explode”, “result type is X”).
    - **No exceptions** for specified valid domains; if invalid, either exception or sentinel—make it explicit.
    Re-raise any exception to let Atheris record a crash.

    ---
    ## 4) Instrumentation (order matters)
    - Use:
      ```python
      with atheris.instrument_imports():
          # import the real target module(s) or paste the provided function
      ```
    - Do **not** mock the target. Call the exact function from “TARGET FUNCTION” (or its module path if provided).
    - Do **not** call `atheris.instrument_all()` after importing; it wont retroactively instrument already-loaded code.

    ---
    ## 5) Harness Skeleton (requirements)
    - At the **very top** (before non-stdlib imports), install packages:
      ```python
      import subprocess, sys
      def _pip(pkg): subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])
      _pip("setuptools"); _pip("wheel"); _pip("atheris")
      # plus any other non-stdlib packages required by the target, inferred from CODE/DOCS
      ```
    - Then:
      ```python
      import os
      os.environ.setdefault("PYTHONHASHSEED", "0")
      import atheris, sys
      with atheris.instrument_imports():
          # import target module or define provided function here
      ```
    - `TestOneInput(data: bytes)`:
      - Build inputs per Section 2.
      - Call the real target.
      - Assert properties per Section 3.
      - Catch **only** broad `Exception` to annotate if you must, but **re-raise** immediately so Atheris/libFuzzer writes `crash-*` artifacts.
    - `atheris.Setup(sys.argv, TestOneInput, enable_python_coverage=True)`
    - `atheris.Fuzz()`

    **Do not**: print continuously, sleep, start threads, or perform network I/O. Keep the hot path lean.

    ---
    ## 6) Recommended run flags (put these in comments at top of script)
    ```
    # Recommended:
    #   -use_value_profile=1
    #   -artifact_prefix=artifacts/
    #   -timeout=10
    #   -print_final_stats=1
    # Seeds (optional but useful): provide a seeds/ dir with small, realistic examples.
    # Dictionary (optional): -dict=dict.txt; include tokens/keywords/regex literals inferred from the target.
    # Max input size: set -max_len to a reasonable upper bound if the target expects large inputs.
    ```

    ---
    ## 7) Acceptance criteria (reject anything that fails this)
    - The code is one file, imports the **real** target inside `instrument_imports()`.
    - The harness compiles without additional edits after pip installs succeed.
    - At least three **meaningful** assertions that connect to the targets semantics.
    - No mocks of the target. No swallowing of exceptions (must re-raise).
    - No noisy logging; only libFuzzer/Atheris output.
    - Uses `FuzzedDataProvider` properly, respecting obvious constraints.

    ---
    {{DOCS}}

    ---
    **TARGET FUNCTION:**

    {{CODE}}
    ---

